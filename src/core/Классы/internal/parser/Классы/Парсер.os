#Использовать "../../lexer"

Перем Спек;

Перем Опции; // Структура Ключ - Значение (Структура описание опции)
Перем Аргументы; // Структура  

Перем ОпцииИндекс; // Соответствие
Перем АргументыИндекс; // Соответствие

Перем ТокеныПарсера;

Перем Парсер_ТекущаяПозиция;
Перем НайденныйТокен;

Перем СкинутьОпции;
Перем ТипыТокенов;

Перем ОбработчикВыборкиПути;

Перем Лог;

Процедура ПриСозданииОбъекта(Знач ТокеныСпек, Знач ПараметрыПарсера)

	ТокеныПарсера = ТокеныСпек;
	Опции = ПараметрыПарсера.Опции;
	Аргументы = ПараметрыПарсера.Аргументы;
	ОпцииИндекс = ПараметрыПарсера.ОпцииИндекс;
	АргументыИндекс = ПараметрыПарсера.АргументыИндекс;
	Спек = ПараметрыПарсера.Спек;
	
	Лог.Отладка("Спек %1", Спек);
	Лог.Отладка("Количество опций: %1", Опции.Количество());
	
	Парсер_ТекущаяПозиция = 0;

	СкинутьОпции = Ложь;

	ТипыТокенов = Токены.ТипыТокенов();
	
	ОбработчикВыборкиПути = Новый ВыборСовпадений();
	
КонецПроцедуры

// Выполняет чтение аргументов строки
//
//  Возвращаемое значение:
//   Объект - ссылка на класс "Совпадение"
//
Функция Прочитать() Экспорт

	Лог.Отладка("Начинаю чтение спека %1", Спек);
	Лог.Отладка("Количество токенов %1", ТокеныПарсера.Количество());

	Результат = ПрочитатьРекурсивно(Ложь);
		
	Если Не КонецТокенов() Тогда
		ВызватьИсключение "Косяк ппц что делать";
	КонецЕсли;

	НачальноеСостояние = Результат.НачальноеСостояние;
	КонечноеСостояние = Результат.КонечноеСостояние;
	
	КонечноеСостояние.Завершено = Истина;
	НачальноеСостояние.Подготовить();

	Возврат НачальноеСостояние;

КонецФункции

Функция ПрочитатьРекурсивно(Требуется)

	Лог.Отладка("Рекурсивное чтение %1", Требуется);
	
	НачальноеСостояние = ОбработчикВыборкиПути.НовоеСостояние();
	КонечноеСостояние = НачальноеСостояние;

	Если Требуется Тогда

		Результат = ТокенВыбора();
		
		Для каждого Соединение Из Результат.НачальноеСостояние.МассивСоединений Цикл
			КонечноеСостояние.Т(Соединение.Парсер, Соединение.СледующееСостояние);
		КонецЦикла;
	
		КонечноеСостояние = Результат.КонечноеСостояние;
	
	КонецЕсли;

	Пока МогуПрочитать() Цикл

		РезультатВЦикле = ТокенВыбора();
		
		Для каждого Соединение Из РезультатВЦикле.НачальноеСостояние.МассивСоединений Цикл
			КонечноеСостояние.Т(Соединение.Парсер, Соединение.СледующееСостояние);
		КонецЦикла;
	
		КонечноеСостояние = РезультатВЦикле.КонечноеСостояние;

	КонецЦикла;

	Возврат Новый Структура("НачальноеСостояние, КонечноеСостояние", НачальноеСостояние, КонечноеСостояние);
		
КонецФункции

Функция ЧтениеДалее()
	
	Лог.Отладка("Вызов <ЧтениеДалее>");

	НачальноеСостояние = ОбработчикВыборкиПути.НовоеСостояние();
	КонечноеСостояние = Неопределено;

	Если КонецТокенов() Тогда
		
		Ошибка("Не правильная строка использования", Парсер_ТекущаяПозиция, Истина);

	ИначеЕсли НашлиТокен(ТипыТокенов.TTArg) Тогда

		Имя = НайденныйТокен.Значение;

		КлассОпции = АргументыИндекс[Имя];
		Если КлассОпции = Неопределено Тогда
			Назад();
			Ошибка("Нашли не объявленный аргумент", Парсер_ТекущаяПозиция, Истина);
		КонецЕсли;

		КонечноеСостояние = НачальноеСостояние.Т(Новый АргументыПарсера(КлассОпции), ОбработчикВыборкиПути.НовоеСостояние());
		
	ИначеЕсли НашлиТокен(ТипыТокенов.TTOptions) Тогда

		Если СкинутьОпции Тогда
			Назад();
			Ошибка("Не нашли опций после --", Парсер_ТекущаяПозиция, Истина);
		КонецЕсли;
		КонечноеСостояние = ОбработчикВыборкиПути.НовоеСостояние();
		НачальноеСостояние.Т(Новый ВсеОпцииПарсера(Опции, ОпцииИндекс), КонечноеСостояние);
	ИначеЕсли НашлиТокен(ТипыТокенов.TTShortOpt)
		ИЛИ НашлиТокен(ТипыТокенов.TTLongOpt) Тогда

		Лог.Отладка("Обрабатываю токен: %1", НайденныйТокен.Тип);
		Если СкинутьОпции Тогда
			Назад();
			Ошибка("Не нашли опций после --", Парсер_ТекущаяПозиция, Истина);
		КонецЕсли;

		Имя = НайденныйТокен.Значение;
		КлассОпции = ОпцииИндекс[Имя];
		Лог.Отладка("		>> Имя токен: %1", НайденныйТокен.Значение);
		Лог.Отладка("		>> класс опции: %1", КлассОпции.Имя);
	
		Если КлассОпции = Неопределено Тогда
			Назад();
			Ошибка("Нашли не объявленную опцию", Парсер_ТекущаяПозиция, Истина);
		КонецЕсли;

		КонечноеСостояние = НачальноеСостояние.Т(Новый ОпцияПарсера(КлассОпции, ОпцииИндекс),
												 ОбработчикВыборкиПути.НовоеСостояние());
		Лог.Отладка("		>> НачальноеСостояние.МассивСоединений: %1", НачальноеСостояние.МассивСоединений.Количество());
		
		НашлиТокен(ТипыТокенов.TTOptValue); // Пропуск значение после "=" 

	ИначеЕсли НашлиТокен(ТипыТокенов.TTOptSeq) Тогда

		Если СкинутьОпции Тогда
			Назад();
			Ошибка("Не нашли опций после --", Парсер_ТекущаяПозиция, Истина);
		КонецЕсли;

		КонечноеСостояние = ОбработчикВыборкиПути.НовоеСостояние();

		ДоступныеОпции = НайденныйТокен.Значение;
		Если СтрНачинаетсяС(ДоступныеОпции, "-") Тогда
			ДоступныеОпции = Прав(ДоступныеОпции, СтрДлина(ДоступныеОпции) - 1);
		КонецЕсли;
		МассивДоступныхОпций  = Новый Соответствие;
		ДлинаОпций = СтрДлина(ДоступныеОпции);
		Для ИИ = 1 По ДлинаОпций Цикл
			
			ИмяОпции = Сред(ДоступныеОпции, ИИ, 1);
			
			КлассОпции = ОпцииИндекс["-" + ИмяОпции];
			
			Если КлассОпции = Неопределено Тогда
				Назад();
				Ошибка("Нашли не объявленную опцию", Парсер_ТекущаяПозиция, Истина);
			КонецЕсли;
	
			МассивДоступныхОпций.Вставить(КлассОпции, КлассОпции);

		КонецЦикла;		

		НачальноеСостояние.Т(Новый ВсеОпцииПарсера(МассивДоступныхОпций, ОпцииИндекс), КонечноеСостояние);

	ИначеЕсли НашлиТокен(ТипыТокенов.TTOpenPar) Тогда

		РезультатЧтения = ПрочитатьРекурсивно(Истина);

		НачальноеСостояние = РезультатЧтения.НачальноеСостояние;
		КонечноеСостояние = РезультатЧтения.КонечноеСостояние;
		
		ОжидаюТокен(ТипыТокенов.TTClosePar);
		
	ИначеЕсли НашлиТокен(ТипыТокенов.TTOpenSq) Тогда
		РезультатЧтения = ПрочитатьРекурсивно(Истина);
		
		НачальноеСостояние = РезультатЧтения.НачальноеСостояние;
		КонечноеСостояние = РезультатЧтения.КонечноеСостояние;
		НачальноеСостояние.Т(Новый ЛюбойСимвол(), КонечноеСостояние);
		
		ОжидаюТокен(ТипыТокенов.TTCloseSq);

	ИначеЕсли НашлиТокен(ТипыТокенов.TTDoubleDash) Тогда
		
		СкинутьОпции = Истина;
		КонечноеСостояние = НачальноеСостояние.Т(Новый ОпцииЗавершениеПарсера(), ОбработчикВыборкиПути.НовоеСостояние());
		
		Возврат Новый Структура("НачальноеСостояние, КонечноеСостояние", НачальноеСостояние, КонечноеСостояние);
	Иначе
		Ошибка("Неизвестный токен", Парсер_ТекущаяПозиция, Истина);
	КонецЕсли;

	Если НашлиТокен(ТипыТокенов.TTRep) Тогда
		КонечноеСостояние.Т(Новый ЛюбойСимвол(), НачальноеСостояние);
	
	КонецЕсли;

	Если КонечноеСостояние = Неопределено Тогда
		Ошибка("Не могу правильно выстроить строку использования", Парсер_ТекущаяПозиция, Истина);
	КонецЕсли;
	
	Возврат Новый Структура("НачальноеСостояние, КонечноеСостояние", НачальноеСостояние, КонечноеСостояние);
	
КонецФункции

Функция ТокенВыбора()
	
	Лог.Отладка("Вызов <ТокенВыбора>");
		
	НачальноеСостояние = ОбработчикВыборкиПути.НовоеСостояние();
	КонечноеСостояние = ОбработчикВыборкиПути.НовоеСостояние();

	Результат = ЧтениеДалее();
	
	НачальноеСостояние.Т(Новый ЛюбойСимвол(), Результат.НачальноеСостояние);
	Результат.КонечноеСостояние.Т(Новый ЛюбойСимвол(), КонечноеСостояние);

	Пока НашлиТокен(ТипыТокенов.TTChoice) Цикл
		Лог.Отладка("Нашли токен %1", ТипыТокенов.TTChoice);
	
		РезультатВЦикле = ЧтениеДалее();
		
		НачальноеСостояние.Т(Новый ЛюбойСимвол(), РезультатВЦикле.НачальноеСостояние);
		РезультатВЦикле.КонечноеСостояние.Т(Новый ЛюбойСимвол(), КонечноеСостояние);
	
	КонецЦикла;
	
	Возврат Новый Структура("НачальноеСостояние, КонечноеСостояние", НачальноеСостояние, КонечноеСостояние);
	
КонецФункции

Процедура ОжидаюТокен(ТипТокена)

	Если НЕ НашлиТокен(ТипТокена) Тогда
		Ошибка("Не найден ожидаемый токен " + ТипТокена, Парсер_ТекущаяПозиция, Истина);
	КонецЕсли;
	
КонецПроцедуры

Процедура Ошибка(Текст, Позиция = Неопределено, Остановить = Ложь)
	Перем ТекстОшибки;
	Если Позиция = Неопределено Тогда
		Позиция = Парсер_ТекущаяПозиция;// Мин(Парсер_ТекущаяПозиция - СтрДлина(Парсер_Литерал), Парсер_Длина);
	КонецЕсли;
	ТекстОшибки = СтрШаблон("[ Кол: %2 ] %3",
		Позиция,
		Текст
	);
	Если Остановить Тогда
		ВызватьИсключение ТекстОшибки;
	Иначе
		Лог.КритичнаяОшибка(ТекстОшибки);
	КонецЕсли;
КонецПроцедуры // Ошибка()

Функция КонецТокенов()

	Возврат Парсер_ТекущаяПозиция >= ТокеныПарсера.Количество();
			
КонецФункции

Процедура Назад()
	
	Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция - 1;
			
КонецПроцедуры

Функция Токен()

	Если КонецТокенов() Тогда
		Возврат Неопределено;
	КонецЕсли;

	Возврат ТокеныПарсера[Парсер_ТекущаяПозиция];
	
КонецФункции

Функция ЭтоТокен(Знач ТипТокена)

	Если КонецТокенов() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Токен().Тип = ТипТокена;
	
КонецФункции

Функция МогуПрочитать()

	Если ЭтоТокен(ТипыТокенов.TTArg)
		ИЛИ ЭтоТокен(ТипыТокенов.TTOptions)
		ИЛИ ЭтоТокен(ТипыТокенов.TTShortOpt)
		ИЛИ ЭтоТокен(ТипыТокенов.TTLongOpt)
		ИЛИ ЭтоТокен(ТипыТокенов.TTOptSeq)
		ИЛИ ЭтоТокен(ТипыТокенов.TTOpenPar)
		ИЛИ ЭтоТокен(ТипыТокенов.TTOpenSq)
		ИЛИ ЭтоТокен(ТипыТокенов.TTDoubleDash)
		Тогда

		Возврат Истина;

	Иначе

		Возврат Ложь;
	КонецЕсли;	
	
КонецФункции

Функция НашлиТокен(Знач ТипТокена)

	Если ЭтоТокен(ТипТокена) Тогда

		Лог.Отладка("Нашли токен: %1", ТипТокена);
		НайденныйТокен = Токен();
		
		Парсер_ТекущаяПозиция = Парсер_ТекущаяПозиция + 1;

		ЛОг.Отладка("Текущая позиция: %1", Парсер_ТекущаяПозиция);

		Возврат Истина;

	КонецЕсли;

	Возврат Ложь;

КонецФункции

Лог = Логирование.ПолучитьЛог("oscript.lib.spec_parse");